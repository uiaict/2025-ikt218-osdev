#include "vga_graphics.h"
#include "util.h"
#include <stddef.h>

static uint8_t* const VGA_GRAPHICS_MEMORY = (uint8_t* const)0xA0000;

uint8_t current_video_mode = VGA_MODE_TEXT;


static uint8_t font8x8[96][8] = {
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 
    {0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x00}, // !
    {0x6C, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00}, // "
    {0x6C, 0x6C, 0xFE, 0x6C, 0xFE, 0x6C, 0x6C, 0x00}, // #
    {0x18, 0x7E, 0xC0, 0x7C, 0x06, 0xFC, 0x18, 0x00}, // $
    {0x00, 0xC6, 0xCC, 0x18, 0x30, 0x66, 0xC6, 0x00}, // %
    {0x38, 0x6C, 0x38, 0x76, 0xDC, 0xCC, 0x76, 0x00}, // &
    {0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00}, // '
    {0x0C, 0x18, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00}, // (
    {0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00}, // )
    {0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00}, // *
    {0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00}, // +
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30}, // ,
    {0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00}, // -
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00}, // .
    {0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00}, 
    
    {0x7C, 0xC6, 0xCE, 0xD6, 0xE6, 0xC6, 0x7C, 0x00}, // 0
    {0x18, 0x38, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00}, // 1
    {0x7C, 0xC6, 0x06, 0x1C, 0x30, 0x60, 0xFE, 0x00}, // 2
    {0x7C, 0xC6, 0x06, 0x3C, 0x06, 0xC6, 0x7C, 0x00}, // 3
    {0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x1E, 0x00}, // 4
    {0xFE, 0xC0, 0xFC, 0x06, 0x06, 0xC6, 0x7C, 0x00}, // 5
    {0x38, 0x60, 0xC0, 0xFC, 0xC6, 0xC6, 0x7C, 0x00}, // 6
    {0xFE, 0xC6, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x00}, // 7
    {0x7C, 0xC6, 0xC6, 0x7C, 0xC6, 0xC6, 0x7C, 0x00}, // 8
    {0x7C, 0xC6, 0xC6, 0x7E, 0x06, 0x0C, 0x78, 0x00}, // 9
    
    {0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x00}, // :
    {0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x30}, // ;
    {0x06, 0x0C, 0x18, 0x30, 0x18, 0x0C, 0x06, 0x00}, // <
    {0x00, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x00, 0x00}, // =
    {0x60, 0x30, 0x18, 0x0C, 0x18, 0x30, 0x60, 0x00}, // >
    {0x7C, 0xC6, 0x0C, 0x18, 0x18, 0x00, 0x18, 0x00}, // ?
    {0x7C, 0xC6, 0xDE, 0xDE, 0xDE, 0xC0, 0x7C, 0x00}, // @
    
    {0x38, 0x6C, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0x00}, // A
    {0xFC, 0x66, 0x66, 0x7C, 0x66, 0x66, 0xFC, 0x00}, // B
    {0x3C, 0x66, 0xC0, 0xC0, 0xC0, 0x66, 0x3C, 0x00}, // C
    {0xF8, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0xF8, 0x00}, // D
    {0xFE, 0x62, 0x68, 0x78, 0x68, 0x62, 0xFE, 0x00}, // E
    {0xFE, 0x62, 0x68, 0x78, 0x68, 0x60, 0xF0, 0x00}, // F
    {0x3C, 0x66, 0xC0, 0xC0, 0xCE, 0x66, 0x3E, 0x00}, // G
    {0xC6, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0x00}, // H
    {0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00}, // I
    {0x1E, 0x0C, 0x0C, 0x0C, 0xCC, 0xCC, 0x78, 0x00}, // J
    {0xE6, 0x66, 0x6C, 0x78, 0x6C, 0x66, 0xE6, 0x00}, // K
    {0xF0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xFE, 0x00}, // L
    {0xC6, 0xEE, 0xFE, 0xFE, 0xD6, 0xC6, 0xC6, 0x00}, // M
    {0xC6, 0xE6, 0xF6, 0xDE, 0xCE, 0xC6, 0xC6, 0x00}, // N
    {0x38, 0x6C, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x00}, // O
    {0xFC, 0x66, 0x66, 0x7C, 0x60, 0x60, 0xF0, 0x00}, // P
    {0x38, 0x6C, 0xC6, 0xC6, 0xCA, 0x6C, 0x3A, 0x00}, // Q
    {0xFC, 0x66, 0x66, 0x7C, 0x6C, 0x66, 0xE6, 0x00}, // R
    {0x7C, 0xC6, 0xE0, 0x78, 0x0E, 0xC6, 0x7C, 0x00}, // S
    {0x7E, 0x5A, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00}, // T
    {0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00}, // U
    {0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x00}, // V
    {0xC6, 0xC6, 0xC6, 0xD6, 0xFE, 0xEE, 0xC6, 0x00}, // W
    {0xC6, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0xC6, 0x00}, // X
    {0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x3C, 0x00}, // Y
    {0xFE, 0xC6, 0x8C, 0x18, 0x32, 0x66, 0xFE, 0x00}, // Z
    
    {0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00}, // [
    {0xC0, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x02, 0x00}, // backslash
    {0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00}, // ]
    {0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00}, // ^
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF}, // _
    {0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00}, // `
    
    {0x00, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x76, 0x00}, // a
    {0xE0, 0x60, 0x60, 0x7C, 0x66, 0x66, 0xDC, 0x00}, // b
    {0x00, 0x00, 0x78, 0xCC, 0xC0, 0xCC, 0x78, 0x00}, // c
    {0x1C, 0x0C, 0x0C, 0x7C, 0xCC, 0xCC, 0x76, 0x00}, // d
    {0x00, 0x00, 0x78, 0xCC, 0xFC, 0xC0, 0x78, 0x00}, // e
    {0x38, 0x6C, 0x60, 0xF0, 0x60, 0x60, 0xF0, 0x00}, // f
    {0x00, 0x00, 0x76, 0xCC, 0xCC, 0x7C, 0x0C, 0xF8}, // g
    {0xE0, 0x60, 0x6C, 0x76, 0x66, 0x66, 0xE6, 0x00}, // h
    {0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x3C, 0x00}, // i
    {0x06, 0x00, 0x06, 0x06, 0x06, 0x66, 0x66, 0x3C}, // j
    {0xE0, 0x60, 0x66, 0x6C, 0x78, 0x6C, 0xE6, 0x00}, // k
    {0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00}, // l
    {0x00, 0x00, 0xCC, 0xFE, 0xFE, 0xD6, 0xC6, 0x00}, // m
    {0x00, 0x00, 0xF8, 0xCC, 0xCC, 0xCC, 0xCC, 0x00}, // n
    {0x00, 0x00, 0x78, 0xCC, 0xCC, 0xCC, 0x78, 0x00}, // o
    {0x00, 0x00, 0xDC, 0x66, 0x66, 0x7C, 0x60, 0xF0}, // p
    {0x00, 0x00, 0x76, 0xCC, 0xCC, 0x7C, 0x0C, 0x1E}, // q
    {0x00, 0x00, 0xDC, 0x76, 0x66, 0x60, 0xF0, 0x00}, // r
    {0x00, 0x00, 0x7C, 0xC0, 0x78, 0x0C, 0xF8, 0x00}, // s
    {0x10, 0x30, 0x7C, 0x30, 0x30, 0x34, 0x18, 0x00}, // t
    {0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00}, // u
    {0x00, 0x00, 0xCC, 0xCC, 0xCC, 0x78, 0x30, 0x00}, // v
    {0x00, 0x00, 0xC6, 0xD6, 0xFE, 0xFE, 0x6C, 0x00}, // w
    {0x00, 0x00, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0x00}, // x
    {0x00, 0x00, 0xCC, 0xCC, 0xCC, 0x7C, 0x0C, 0xF8}, // y
    {0x00, 0x00, 0xFC, 0x98, 0x30, 0x64, 0xFC, 0x00}  // z
};

void set_mode_13h() {
    outPortB(0x3C2, 0x63);
    outPortB(0x3D4, 0x00); outPortB(0x3D5, 0x5F);
    outPortB(0x3D4, 0x01); outPortB(0x3D5, 0x4F);
    outPortB(0x3D4, 0x02); outPortB(0x3D5, 0x50);
    outPortB(0x3D4, 0x03); outPortB(0x3D5, 0x82);
    outPortB(0x3D4, 0x04); outPortB(0x3D5, 0x54);
    outPortB(0x3D4, 0x05); outPortB(0x3D5, 0x80);
    outPortB(0x3D4, 0x06); outPortB(0x3D5, 0xBF);
    outPortB(0x3D4, 0x07); outPortB(0x3D5, 0x1F);
    outPortB(0x3D4, 0x08); outPortB(0x3D5, 0x00);
    outPortB(0x3D4, 0x09); outPortB(0x3D5, 0x41);
    outPortB(0x3D4, 0x10); outPortB(0x3D5, 0x9C);
    outPortB(0x3D4, 0x11); outPortB(0x3D5, 0x8E);
    outPortB(0x3D4, 0x12); outPortB(0x3D5, 0x8F);
    outPortB(0x3D4, 0x13); outPortB(0x3D5, 0x28);
    outPortB(0x3D4, 0x14); outPortB(0x3D5, 0x40);
    outPortB(0x3D4, 0x15); outPortB(0x3D5, 0x96);
    outPortB(0x3D4, 0x16); outPortB(0x3D5, 0xB9);
    outPortB(0x3D4, 0x17); outPortB(0x3D5, 0xA3);
    outPortB(0x3C4, 0x01); outPortB(0x3C5, 0x08);
    outPortB(0x3C4, 0x02); outPortB(0x3C5, 0x0F);
    outPortB(0x3C4, 0x03); outPortB(0x3C5, 0x00);
    outPortB(0x3C4, 0x04); outPortB(0x3C5, 0x0E);
    outPortB(0x3CE, 0x05); outPortB(0x3CF, 0x40);
    outPortB(0x3CE, 0x06); outPortB(0x3CF, 0x05);
    outPortB(0x3C0, 0x30); outPortB(0x3C0, 0x41);
    outPortB(0x3C0, 0x33); outPortB(0x3C0, 0x00);
    
    outPortB(0x3C0, 0x10);
    outPortB(0x3C0, 0x41);
    
    outPortB(0x3D4, 0x13);
    outPortB(0x3D5, 0x28);
    
    current_video_mode = VGA_MODE_13H;
    
    clear_screen_graphics(0);
}

void set_mode_text() {
    outPortB(0x3C2, 0x67);
    outPortB(0x3D4, 0x00); outPortB(0x3D5, 0x5F);
    outPortB(0x3D4, 0x01); outPortB(0x3D5, 0x4F);
    outPortB(0x3D4, 0x02); outPortB(0x3D5, 0x50);
    outPortB(0x3D4, 0x03); outPortB(0x3D5, 0x82);
    outPortB(0x3D4, 0x04); outPortB(0x3D5, 0x55);
    outPortB(0x3D4, 0x05); outPortB(0x3D5, 0x81);
    outPortB(0x3D4, 0x06); outPortB(0x3D5, 0xBF);
    outPortB(0x3D4, 0x07); outPortB(0x3D5, 0x1F);
    outPortB(0x3D4, 0x08); outPortB(0x3D5, 0x00);
    outPortB(0x3D4, 0x09); outPortB(0x3D5, 0x4F);
    outPortB(0x3D4, 0x10); outPortB(0x3D5, 0x9C);
    outPortB(0x3D4, 0x11); outPortB(0x3D5, 0x8E);
    outPortB(0x3D4, 0x12); outPortB(0x3D5, 0x8F);
    outPortB(0x3D4, 0x13); outPortB(0x3D5, 0x28);
    outPortB(0x3D4, 0x14); outPortB(0x3D5, 0x1F);
    outPortB(0x3D4, 0x15); outPortB(0x3D5, 0x96);
    outPortB(0x3D4, 0x16); outPortB(0x3D5, 0xB9);
    outPortB(0x3D4, 0x17); outPortB(0x3D5, 0xA3);
    outPortB(0x3C4, 0x01); outPortB(0x3C5, 0x00);
    outPortB(0x3C4, 0x02); outPortB(0x3C5, 0x03);
    outPortB(0x3C4, 0x03); outPortB(0x3C5, 0x00);
    outPortB(0x3C4, 0x04); outPortB(0x3C5, 0x02);
    outPortB(0x3CE, 0x05); outPortB(0x3CF, 0x10);
    outPortB(0x3CE, 0x06); outPortB(0x3CF, 0x0E);
    outPortB(0x3C0, 0x30); outPortB(0x3C0, 0x01);
    outPortB(0x3C0, 0x33); outPortB(0x3C0, 0x03);
    
    outPortB(0x3C0, 0x10);
    outPortB(0x3C0, 0x0C);
    
    current_video_mode = VGA_MODE_TEXT;
    
    Reset();
}

void plot_pixel(uint16_t x, uint16_t y, uint8_t color) {
    if (current_video_mode != VGA_MODE_13H || 
        x >= GRAPHICS_WIDTH || y >= GRAPHICS_HEIGHT) {
        return;
    }
    
    uint32_t offset = y * GRAPHICS_WIDTH + x;
    VGA_GRAPHICS_MEMORY[offset] = color;
}

void draw_hline(uint16_t x, uint16_t y, uint16_t length, uint8_t color) {
    if (current_video_mode != VGA_MODE_13H || 
        y >= GRAPHICS_HEIGHT || x >= GRAPHICS_WIDTH) {
        return;
    }
    
    if (x + length >= GRAPHICS_WIDTH) {
        length = GRAPHICS_WIDTH - x - 1;
    }
    
    for (uint16_t i = 0; i < length; i++) {
        plot_pixel(x + i, y, color);
    }
}

void draw_vline(uint16_t x, uint16_t y, uint16_t length, uint8_t color) {
    if (current_video_mode != VGA_MODE_13H || 
        x >= GRAPHICS_WIDTH || y >= GRAPHICS_HEIGHT) {
        return;
    }
    
    if (y + length >= GRAPHICS_HEIGHT) {
        length = GRAPHICS_HEIGHT - y - 1;
    }
    
    for (uint16_t i = 0; i < length; i++) {
        plot_pixel(x, y + i, color);
    }
}

void draw_line(uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint8_t color) {
    if (current_video_mode != VGA_MODE_13H || 
        x1 >= GRAPHICS_WIDTH || y1 >= GRAPHICS_HEIGHT || 
        x2 >= GRAPHICS_WIDTH || y2 >= GRAPHICS_HEIGHT) {
        return;
    }
    
    if (y1 == y2) {
        draw_hline(x1 < x2 ? x1 : x2, y1, x1 < x2 ? x2 - x1 : x1 - x2, color);
        return;
    }
    if (x1 == x2) {
        draw_vline(x1, y1 < y2 ? y1 : y2, y1 < y2 ? y2 - y1 : y1 - y2, color);
        return;
    }
    
    // Bresenham's line algorithm
    int dx = x2 - x1;
    int dy = y2 - y1;
    int absdx = dx > 0 ? dx : -dx;
    int absdy = dy > 0 ? dy : -dy;
    int x = x1;
    int y = y1;
    int x_inc = dx > 0 ? 1 : -1;
    int y_inc = dy > 0 ? 1 : -1;
    
    // Determine if x or y changes more rapidly
    if (absdx > absdy) {
        // X changes more rapidly
        int error = absdx / 2;
        for (int i = 0; i <= absdx; i++) {
            plot_pixel(x, y, color);
            error -= absdy;
            if (error < 0) {
                y += y_inc;
                error += absdx;
            }
            x += x_inc;
        }
    } else {
        // Y changes more rapidly
        int error = absdy / 2;
        for (int i = 0; i <= absdy; i++) {
            plot_pixel(x, y, color);
            error -= absdx;
            if (error < 0) {
                x += x_inc;
                error += absdy;
            }
            y += y_inc;
        }
    }
}

// Draw a rectangle outline
void draw_rect(uint16_t x, uint16_t y, uint16_t width, uint16_t height, uint8_t color) {
    draw_hline(x, y, width, color);
    draw_hline(x, y + height - 1, width, color);
    draw_vline(x, y, height, color);
    draw_vline(x + width - 1, y, height, color);
}

// Draw a filled rectangle
void fill_rect(uint16_t x, uint16_t y, uint16_t width, uint16_t height, uint8_t color) {
    for (uint16_t i = 0; i < height; i++) {
        draw_hline(x, y + i, width, color);
    }
}

// Draw a circle outline using Bresenham's circle algorithm
void draw_circle(uint16_t x, uint16_t y, uint16_t radius, uint8_t color) {
    int f = 1 - radius;
    int ddF_x = 0;
    int ddF_y = -2 * radius;
    int cx = 0;
    int cy = radius;
    
    plot_pixel(x, y + radius, color);
    plot_pixel(x, y - radius, color);
    plot_pixel(x + radius, y, color);
    plot_pixel(x - radius, y, color);
    
    while (cx < cy) {
        if (f >= 0) {
            cy--;
            ddF_y += 2;
            f += ddF_y;
        }
        cx++;
        ddF_x += 2;
        f += ddF_x + 1;
        
        plot_pixel(x + cx, y + cy, color);
        plot_pixel(x - cx, y + cy, color);
        plot_pixel(x + cx, y - cy, color);
        plot_pixel(x - cx, y - cy, color);
        plot_pixel(x + cy, y + cx, color);
        plot_pixel(x - cy, y + cx, color);
        plot_pixel(x + cy, y - cx, color);
        plot_pixel(x - cy, y - cx, color);
    }
}

// Draw a filled circle using Bresenham's algorithm
void fill_circle(uint16_t x, uint16_t y, uint16_t radius, uint8_t color) {
    int f = 1 - radius;
    int ddF_x = 0;
    int ddF_y = -2 * radius;
    int cx = 0;
    int cy = radius;
    
    draw_hline(x - radius, y, 2 * radius, color);
    
    while (cx < cy) {
        if (f >= 0) {
            cy--;
            ddF_y += 2;
            f += ddF_y;
        }
        cx++;
        ddF_x += 2;
        f += ddF_x + 1;
        
        draw_hline(x - cx, y + cy, 2 * cx, color);
        draw_hline(x - cx, y - cy, 2 * cx, color);
        draw_hline(x - cy, y + cx, 2 * cy, color);
        draw_hline(x - cy, y - cx, 2 * cy, color);
    }
}

void clear_screen_graphics(uint8_t color) {
    if (current_video_mode != VGA_MODE_13H) {
        return;
    }
    
    for (uint32_t i = 0; i < GRAPHICS_WIDTH * GRAPHICS_HEIGHT; i++) {
        VGA_GRAPHICS_MEMORY[i] = color;
    }
}

void draw_char_graphics(uint16_t x, uint16_t y, char c, uint8_t color) {
    if (c < 32 || c > 126) {
        return;
    }
    
    uint8_t index = c - 32;
    
    for (uint8_t row = 0; row < 8; row++) {
        uint8_t row_data = font8x8[index][row];
        for (uint8_t col = 0; col < 8; col++) {
            if ((row_data >> col) & 1) {
                plot_pixel(x + col, y + row, color);
            }
        }
    }
}

void draw_string_graphics(uint16_t x, uint16_t y, const char* str, uint8_t color) {
    uint16_t curr_x = x;
    uint16_t curr_y = y;
    
    while (*str) {
        char c = *str++;
        
        if (c == '\n') {
            curr_x = x;
            curr_y += 8;  
            continue;
        }
        
        if (c == '\r') {
            curr_x = x;
            continue;
        }
        
        draw_char_graphics(curr_x, curr_y, c, color);
        
        curr_x += 8; 
        
        if (curr_x >= GRAPHICS_WIDTH - 8) {
            curr_x = x;
            curr_y += 8;
        }
    }
}